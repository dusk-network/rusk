// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

use crate::gadgets::{
    merkle::merkle, nullifier::nullifier_gadget, preimage::input_preimage,
    range::range, schnorr::schnorr_gadget_two_keys,
};
use anyhow::Result;
use dusk_plonk::bls12_381::BlsScalar;
use dusk_plonk::constraint_system::ecc::scalar_mul::fixed_base::scalar_mul;
use dusk_plonk::constraint_system::ecc::Point as PlonkPoint;
use dusk_plonk::jubjub::{
    JubJubAffine as AffinePoint, GENERATOR_EXTENDED, GENERATOR_NUMS_EXTENDED,
};
use dusk_plonk::prelude::*;
use plonk_gadgets::AllocatedScalar;
use poseidon252::tree::PoseidonBranch;

/// The circuit responsible for creating a zero-knowledge proof
/// for a 'send to contract transparent' transaction.
#[derive(Debug, Default, Clone)]
pub struct ExecuteCircuit {
    /// Storage height of the tree
    // pub anchor: Option<BlsScalar>,
    /// Nullifier for note
    pub nullifiers: Vec<BlsScalar>,
    /// Note hashes
    pub note_hashes: Vec<BlsScalar>,
    /// Positions of notes
    pub position_of_notes: Vec<BlsScalar>,
    /// Input note types
    pub input_note_types: Vec<BlsScalar>,
    /// Poseidon branches of the input notes
    pub input_poseidon_branches: Vec<PoseidonBranch<31>>,
    /// Input notes secret keys
    pub input_notes_sk: Vec<JubJubScalar>,
    /// Input notes public keys
    pub input_notes_pk: Vec<AffinePoint>,
    /// Input notes prime public keys
    pub input_notes_pk_prime: Vec<AffinePoint>,
    /// Input commitment points
    pub input_commitments: Vec<AffinePoint>,
    /// Input nonces
    pub input_nonces: Vec<JubJubScalar>,
    /// Input note values
    pub input_values: Vec<BlsScalar>,
    /// Input notes blinders
    pub input_blinders: Vec<BlsScalar>,
    /// Input notes randomness
    pub input_randomness: Vec<AffinePoint>,
    /// Inputs notes ciphers
    pub input_ciphers_one: Vec<BlsScalar>,
    pub input_ciphers_two: Vec<BlsScalar>,
    pub input_ciphers_three: Vec<BlsScalar>,
    /// Schnorr signatures of nullifiers
    pub schnorr_sigs: Vec<JubJubScalar>,
    /// R generated by Schnorr signatures
    pub schnorr_r: Vec<AffinePoint>,
    /// R_prime generated by Schnorr signatures
    pub schnorr_r_prime: Vec<AffinePoint>,
    /// Schnorr messages
    pub schnorr_messages: Vec<BlsScalar>,
    /// Commitment point to crossover
    pub crossover_commitment: AffinePoint,
    /// Crossover commitment value
    pub crossover_commitment_value: BlsScalar,
    /// Crossover commitment blinder
    pub crossover_commitment_blinder: BlsScalar,
    /// Obfuscated note commitments
    pub obfuscated_commitment_points: Vec<AffinePoint>,
    /// Obfuscated note values
    pub obfuscated_note_values: Vec<BlsScalar>,
    /// Obfuscated note blinder
    pub obfuscated_note_blinders: Vec<BlsScalar>,
    /// Fee
    pub fee: BlsScalar,
    /// Returns circuit size
    pub trim_size: usize,
    /// Gives Public Inputs
    pub pi_positions: Vec<PublicInput>,
}

impl Circuit<'_> for ExecuteCircuit {
    fn gadget(&mut self, composer: &mut StandardComposer) -> Result<()> {
        let nullifiers = self.nullifiers.clone();
        let note_hashes: Vec<AllocatedScalar> = self
            .note_hashes
            .iter()
            .map(|note_hash| AllocatedScalar::allocate(composer, *note_hash))
            .collect();
        let position_of_notes: Vec<AllocatedScalar> = self
            .position_of_notes
            .iter()
            .map(|position_of_notes| {
                AllocatedScalar::allocate(composer, *position_of_notes)
            })
            .collect();
        let input_note_types: Vec<AllocatedScalar> = self
            .input_note_types
            .iter()
            .map(|input_note_types| {
                AllocatedScalar::allocate(composer, *input_note_types)
            })
            .collect();
        let input_poseidon_branches = self.input_poseidon_branches.clone();
        let input_notes_sk: Vec<AllocatedScalar> = self
            .input_notes_sk
            .iter()
            .map(|input_notes_sk| {
                AllocatedScalar::allocate(
                    composer,
                    BlsScalar::from(*input_notes_sk),
                )
            })
            .collect();
        let input_notes_pk: Vec<PlonkPoint> = self
            .input_notes_pk
            .iter()
            .map(|input_notes_pk| {
                PlonkPoint::from_private_affine(composer, *input_notes_pk)
            })
            .collect();
        let input_notes_pk_prime: Vec<PlonkPoint> = self
            .input_notes_pk_prime
            .iter()
            .map(|input_notes_pk_prime| {
                PlonkPoint::from_private_affine(composer, *input_notes_pk_prime)
            })
            .collect();
        let input_commitments: Vec<PlonkPoint> = self
            .input_commitments
            .iter()
            .map(|input_commitments| {
                PlonkPoint::from_private_affine(composer, *input_commitments)
            })
            .collect();
        let input_nonces: Vec<AllocatedScalar> = self
            .input_nonces
            .iter()
            .map(|input_nonces| {
                AllocatedScalar::allocate(
                    composer,
                    BlsScalar::from(*input_nonces),
                )
            })
            .collect();
        if self.input_values.is_empty() {
            return Err(CircuitErrors::CircuitInputsNotFound.into());
        };
        let mut input_note_values: Vec<AllocatedScalar> = self
            .input_values
            .iter()
            .map(|input_values| {
                AllocatedScalar::allocate(composer, *input_values)
            })
            .collect();
        let input_notes_blinders: Vec<AllocatedScalar> = self
            .input_blinders
            .iter()
            .map(|input_blinders| {
                AllocatedScalar::allocate(composer, *input_blinders)
            })
            .collect();
        let input_randomness: Vec<PlonkPoint> = self
            .input_randomness
            .iter()
            .map(|input_randomness| {
                PlonkPoint::from_private_affine(composer, *input_randomness)
            })
            .collect();
        let input_ciphers_one: Vec<AllocatedScalar> = self
            .input_ciphers_one
            .iter()
            .map(|input_ciphers_one| {
                AllocatedScalar::allocate(composer, *input_ciphers_one)
            })
            .collect();
        let input_ciphers_two: Vec<AllocatedScalar> = self
            .input_ciphers_two
            .iter()
            .map(|input_ciphers_two| {
                AllocatedScalar::allocate(composer, *input_ciphers_two)
            })
            .collect();
        let input_ciphers_three: Vec<AllocatedScalar> = self
            .input_ciphers_three
            .iter()
            .map(|input_ciphers_three| {
                AllocatedScalar::allocate(composer, *input_ciphers_three)
            })
            .collect();
        let schnorr_sigs: Vec<AllocatedScalar> = self
            .schnorr_sigs
            .iter()
            .map(|schnorr_sigs| {
                AllocatedScalar::allocate(
                    composer,
                    BlsScalar::from(*schnorr_sigs),
                )
            })
            .collect();
        let schnorr_r: Vec<PlonkPoint> = self
            .schnorr_r
            .iter()
            .map(|schnorr_r| {
                PlonkPoint::from_private_affine(composer, *schnorr_r)
            })
            .collect();
        let schnorr_r_prime: Vec<PlonkPoint> = self
            .schnorr_r_prime
            .iter()
            .map(|schnorr_r_prime| {
                PlonkPoint::from_private_affine(composer, *schnorr_r_prime)
            })
            .collect();
        let schnorr_messages: Vec<AllocatedScalar> = self
            .schnorr_messages
            .iter()
            .map(|schnorr_messages| {
                AllocatedScalar::allocate(composer, *schnorr_messages)
            })
            .collect();
        let crossover_commitment = self.crossover_commitment;
        let crossover_commitment_value = self.crossover_commitment_value;
        let crossover_commitment_blinder = self.crossover_commitment_blinder;
        let obfuscated_commitment_points =
            self.obfuscated_commitment_points.clone();
        let mut obfuscated_note_values: Vec<AllocatedScalar> = self
            .obfuscated_note_values
            .iter()
            .map(|obfuscated_note_values| {
                AllocatedScalar::allocate(composer, *obfuscated_note_values)
            })
            .collect();
        let obfuscated_note_blinders: Vec<AllocatedScalar> = self
            .obfuscated_note_blinders
            .iter()
            .map(|obfuscated_note_blinders| {
                AllocatedScalar::allocate(composer, *obfuscated_note_blinders)
            })
            .collect();
        let fee = self.fee;
        let pi = self.get_mut_pi_positions();

        let crossover_value =
            AllocatedScalar::allocate(composer, crossover_commitment_value);
        let crossover_blinder =
            AllocatedScalar::allocate(composer, crossover_commitment_blinder);

        // 1. Prove the knowledge of the input Note paths to Note Tree, via root
        // anchor

        // Iterate over the branch of each note and push the roots into the
        // vector of public inputs
        input_poseidon_branches
            .iter()
            .zip(note_hashes.iter())
            .for_each(|(branch, note_hash)| {
                let root = merkle(composer, branch.clone(), *note_hash);

                pi.push(PublicInput::BlsScalar(
                    branch.root(),
                    composer.circuit_size(),
                ));

                composer.constrain_to_constant(
                    root,
                    BlsScalar::zero(),
                    -branch.root(),
                );
            });

        // 2. Prove the knowledge of the pre-images of the input Notes

        // Iterate over the note elements and hash them together
        // and constrain against the hash of the note.
        input_note_types
            .iter()
            .zip(input_commitments.iter())
            .zip(input_nonces.iter())
            .zip(input_notes_pk.iter())
            .zip(input_randomness.iter())
            .zip(position_of_notes.iter())
            .zip(input_ciphers_one.iter())
            .zip(input_ciphers_two.iter())
            .zip(input_ciphers_three.iter())
            .zip(note_hashes.iter())
            .for_each(
                |(
                    (
                        (
                            (
                                (
                                    (
                                        (
                                            ((note_type, commitment), nonce),
                                            pk_r,
                                        ),
                                        randomness,
                                    ),
                                    position,
                                ),
                                cipher_one,
                            ),
                            cipher_two,
                        ),
                        cipher_three,
                    ),
                    note_hash,
                )| {
                    let computed_hash = input_preimage(
                        composer,
                        *note_type,
                        *commitment,
                        *nonce,
                        *pk_r,
                        *randomness,
                        *position,
                        *cipher_one,
                        *cipher_two,
                        *cipher_three,
                    );

                    composer.assert_equal(computed_hash, note_hash.var);
                },
            );

        // 3. Prove the correctness of the Schnorr signatures.

        schnorr_sigs
            .iter()
            .zip(schnorr_r.iter())
            .zip(schnorr_r_prime.iter())
            .zip(input_notes_pk.iter())
            .zip(input_notes_pk_prime.iter())
            .zip(schnorr_messages.iter())
            .for_each(|(((((sig, R), R_prime), pk), pk_prime), message)| {
                schnorr_gadget_two_keys(
                    composer, *sig, *R, *R_prime, *pk, *pk_prime, *message,
                );
            });

        // 4. Prove the correctness of the nullifiers

        input_notes_sk
            .iter()
            .zip(position_of_notes.iter())
            .zip(nullifiers.iter())
            .for_each(|((sk, note_position), nullifier)| {
                let computed_nullifier =
                    nullifier_gadget(composer, *note_position, *sk);

                // Push Public nullifiers
                pi.push(PublicInput::BlsScalar(
                    *nullifier,
                    composer.circuit_size(),
                ));

                // Assert generated nullifiers are equal to publicly inputted
                // nullifiers
                composer.constrain_to_constant(
                    computed_nullifier,
                    BlsScalar::zero(),
                    -nullifier,
                );
            });

        // 5. Prove the knowledge of the commitment openings of the commitments
        // of the input Notes
        input_note_values
            .iter()
            .zip(input_notes_blinders.iter())
            .zip(input_commitments.iter())
            .for_each(|((value, blinder), input_commitment)| {
                let p1 = scalar_mul(composer, value.var, GENERATOR_EXTENDED);
                let p2 =
                    scalar_mul(composer, blinder.var, GENERATOR_NUMS_EXTENDED);

                let commitment = p1.point().fast_add(composer, *p2.point());

                // Assert computed commitment is equal to publicly inputted
                // affine point
                composer.assert_equal_point(commitment, *input_commitment);
            });

        // 6. Prove that the value of the openings of the commitments of the
        // input Notes is in range
        input_note_values.iter().for_each(|value| {
            range(composer, *value, 64);
        });

        // 7. Prove the knowledge of the commitment opening of the commitment of
        // the Crossover
        let p3 = scalar_mul(composer, crossover_value.var, GENERATOR_EXTENDED);
        let p4 = scalar_mul(
            composer,
            crossover_blinder.var,
            GENERATOR_NUMS_EXTENDED,
        );

        let commitment = p3.point().fast_add(composer, *p4.point());

        // Add PI constraint for the commitment computation check.
        pi.push(PublicInput::AffinePoint(
            crossover_commitment,
            composer.circuit_size(),
            composer.circuit_size() + 1,
        ));

        // Assert computed commitment is equal to publicly inputted affine point
        composer.assert_equal_public_point(commitment, crossover_commitment);

        // 8. Prove that the value of the opening of the commitment of the
        // Crossover is within range
        range(composer, crossover_value, 64);

        // 9. Prove the knowledge of the commitment openings of the commitments
        // of the output Obfuscated Notes
        obfuscated_note_values
            .iter()
            .zip(obfuscated_note_blinders.iter())
            .zip(obfuscated_commitment_points.iter())
            .for_each(|((value, blinder), obfuscated_commitment_points)| {
                let p5 = scalar_mul(composer, value.var, GENERATOR_EXTENDED);
                let p6 =
                    scalar_mul(composer, blinder.var, GENERATOR_NUMS_EXTENDED);

                let commitment = p5.point().fast_add(composer, *p6.point());

                // Add PI constraint for the commitment computation check.
                pi.push(PublicInput::AffinePoint(
                    *obfuscated_commitment_points,
                    composer.circuit_size(),
                    composer.circuit_size() + 1,
                ));
                // Assert computed commitment is equal to publicly inputted
                // affine point
                composer.assert_equal_public_point(
                    commitment,
                    *obfuscated_commitment_points,
                );
            });

        // 10. Prove that the value of the openings of the commitments of the
        // output Obfuscated Notes is in range
        obfuscated_note_values.iter().for_each(|value| {
            range(composer, *value, 64);
        });

        // 11. Prove that input_note_value - output_note_value - crossover_value
        // - fee = 0
        let zero =
            composer.add_witness_to_circuit_description(BlsScalar::zero());

        let initial = input_note_values[0].var;
        let all_input_values = input_note_values.iter_mut().skip(1).fold(
            initial,
            |acc, variable| {
                composer.add(
                    (BlsScalar::one(), acc),
                    (BlsScalar::one(), variable.var),
                    BlsScalar::zero(),
                    BlsScalar::zero(),
                )
            },
        );

        let initial = if obfuscated_note_values.is_empty() {
            zero
        } else {
            obfuscated_note_values[0].var
        };

        let all_obfuscated_values = obfuscated_note_values
            .iter_mut()
            .skip(1)
            .fold(initial, |acc, variable| {
                composer.add(
                    (BlsScalar::one(), acc),
                    (BlsScalar::one(), variable.var),
                    BlsScalar::zero(),
                    BlsScalar::zero(),
                )
            });

        pi.push(PublicInput::BlsScalar(fee, composer.circuit_size()));

        let crossover_commitment_value =
            AllocatedScalar::allocate(composer, crossover_commitment_value);
        composer.add_gate(
            crossover_commitment_value.var,
            all_obfuscated_values,
            all_input_values,
            BlsScalar::one(),
            BlsScalar::one(),
            -BlsScalar::one(),
            BlsScalar::zero(),
            fee,
        );

        Ok(())
    }

    /// Returns the size at which we trim the `PublicParameters`
    /// to compile the circuit or perform proving/verification
    /// actions.
    fn get_trim_size(&self) -> usize {
        self.trim_size
    }

    fn set_trim_size(&mut self, size: usize) {
        self.trim_size = size;
    }

    /// /// Return a mutable reference to the Public Inputs storage of the
    /// circuit.
    fn get_mut_pi_positions(&mut self) -> &mut Vec<PublicInput> {
        &mut self.pi_positions
    }

    /// Return a reference to the Public Inputs storage of the circuit.
    fn get_pi_positions(&self) -> &Vec<PublicInput> {
        &self.pi_positions
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::leaf::NoteLeaf;
    use anyhow::Result;
    use canonical_host::MemStore;
    use dusk_pki::{Ownable, PublicSpendKey, SecretSpendKey};
    use dusk_plonk::commitment_scheme::kzg10::PublicParameters;
    use phoenix_core::{Note, NoteType};
    use poseidon252::sponge::hash;
    use poseidon252::tree::{PoseidonAnnotation, PoseidonBranch, PoseidonTree};

    // Function to generate value commitment from value and blinder. This is a
    // pedersen commitment.
    fn compute_value_commitment(
        value: JubJubScalar,
        blinder: JubJubScalar,
    ) -> AffinePoint {
        let commitment = AffinePoint::from(
            &(GENERATOR_EXTENDED * value)
                + &(GENERATOR_NUMS_EXTENDED * blinder),
        );

        commitment
    }

    // Function to build execute circuit from given circuit inputs
    fn build_execute_circuit(
        nullifiers: Vec<BlsScalar>,
        note_hashes: Vec<BlsScalar>,
        position_of_notes: Vec<BlsScalar>,
        input_note_types: Vec<BlsScalar>,
        input_poseidon_branches: Vec<PoseidonBranch<17>>,
        input_notes_sk: Vec<JubJubScalar>,
        input_notes_pk: Vec<AffinePoint>,
        input_notes_pk_prime: Vec<AffinePoint>,
        input_commitments: Vec<AffinePoint>,
        input_nonces: Vec<JubJubScalar>,
        input_values: Vec<BlsScalar>,
        input_blinders: Vec<BlsScalar>,
        input_randomness: Vec<AffinePoint>,
        input_ciphers_one: Vec<BlsScalar>,
        input_ciphers_two: Vec<BlsScalar>,
        input_ciphers_three: Vec<BlsScalar>,
        schnorr_sigs: Vec<JubJubScalar>,
        schnorr_r: Vec<AffinePoint>,
        schnorr_r_prime: Vec<AffinePoint>,
        schnorr_messages: Vec<BlsScalar>,
        crossover_commitment: AffinePoint,
        crossover_commitment_value: BlsScalar,
        crossover_commitment_blinder: BlsScalar,
        obfuscated_commitment_points: Vec<AffinePoint>,
        obfuscated_note_values: Vec<BlsScalar>,
        obfuscated_note_blinders: Vec<BlsScalar>,
        fee: BlsScalar,
    ) -> ExecuteCircuit {
        ExecuteCircuit {
            nullifiers,
            note_hashes,
            position_of_notes,
            input_note_types,
            input_poseidon_branches,
            input_notes_sk,
            input_notes_pk,
            input_notes_pk_prime,
            input_commitments,
            input_nonces,
            input_values,
            input_blinders,
            input_randomness,
            input_ciphers_one,
            input_ciphers_two,
            input_ciphers_three,
            schnorr_sigs,
            schnorr_r,
            schnorr_r_prime,
            schnorr_messages,
            crossover_commitment,
            crossover_commitment_value: crossover_commitment_value.into(),
            crossover_commitment_blinder: crossover_commitment_blinder.into(),
            obfuscated_commitment_points,
            obfuscated_note_values,
            obfuscated_note_blinders,
            fee,
            trim_size: 1 << 16,
            pi_positions: vec![],
        }
    }

    fn add_circuit_public_inputs(
        circuit: &ExecuteCircuit,
        crossover_commitment: AffinePoint,
        fee: BlsScalar,
        pi: &mut Vec<PublicInput>,
    ) {
        circuit.input_poseidon_branches.iter().for_each(|branch| {
            pi.push(PublicInput::BlsScalar(branch.root(), 0));
        });
        circuit.nullifiers.iter().for_each(|nullifier| {
            pi.push(PublicInput::BlsScalar(*nullifier, 0));
        });

        pi.push(PublicInput::AffinePoint(crossover_commitment, 0, 0));

        circuit.obfuscated_commitment_points.iter().for_each(
            |commitment_point| {
                pi.push(PublicInput::AffinePoint(*commitment_point, 0, 0));
            },
        );

        pi.push(PublicInput::BlsScalar(-fee, 0));
    }

    // Function to create deterministic note from chosen instantiated parameters
    fn circuit_note(
        ssk: SecretSpendKey,
        value: u64,
        pos: u64,
        input_note_blinder: JubJubScalar,
    ) -> Note {
        let r = JubJubScalar::from(150 as u64);
        let nonce = JubJubScalar::from(350 as u64);
        let psk = PublicSpendKey::from(&ssk);
        let mut note = Note::deterministic(
            NoteType::Transparent,
            &r,
            nonce,
            &psk,
            value,
            input_note_blinder,
        );
        note.set_pos(pos);
        note
    }

    // This function is used to create a Schnorr signature
    // which are then verified in the circuit. Standardly, the user
    // will provide the signatures directly into the circuit.
    fn schnorr_sign(
        sk: JubJubScalar,
        message: BlsScalar,
    ) -> (JubJubScalar, AffinePoint, AffinePoint, AffinePoint) {
        let pk_prime = AffinePoint::from(GENERATOR_NUMS_EXTENDED * sk);
        let r = JubJubScalar::random(&mut rand::thread_rng());
        let R = AffinePoint::from(GENERATOR_EXTENDED * r);
        let R_prime = AffinePoint::from(GENERATOR_NUMS_EXTENDED * r);
        let h = hash(&[message]);
        let c_hash =
            hash(&[R.get_x(), R.get_y(), R_prime.get_x(), R_prime.get_y(), h]);
        let c_hash = c_hash & BlsScalar::pow_of_2(250).sub(&BlsScalar::one());
        let c = JubJubScalar::from_bytes(&c_hash.to_bytes()).unwrap();
        let U = r - (c * sk);
        (U, R, R_prime, pk_prime)
    }

    #[test]
    // This test ensures the execute gadget is done correctly
    // by creating two notes and setting their field values
    // in the execute circuit
    fn test_execute() -> Result<()> {
        // Generate the (a,b) for the note
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        // Declare the secret spend key for the note
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        // Assign the value of the note
        let value1 = 600u64;
        let input_note_blinder_one = JubJubScalar::from(100 as u64);
        // Create a deterministic note so that we can assign the blinder and not
        // have inner randomness
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        // Set the position of the note
        note1.set_pos(0);
        // Derive the one time public key, pk_r, for the note
        let input_note_value_one = JubJubScalar::from(value1);
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        // Generate the (a,b) for the note
        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        // Declare the secret spend key for the note
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        // Assign the value of the first note as 400, which is incorrect
        let value2 = 200u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        // Create a deterministic note so that we can assign the blinder and not
        // have inner randomness
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        // Set the position of the note
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        // Generate the value commitment of the note from the value and blinder
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        // Assign the postitions of the notes to a position in the tree
        let tree_pos_1 = tree.push(note1.into()).expect("Tree appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Tree appending error");

        // Generate the crossover commitment, C.c(v,b)
        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        // Generate the commitment to the first output note, C.c(v,b)
        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        // Generate the commitment to the second output note, C.c(v,b)
        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        // Assign the fee
        let fee = BlsScalar::from(200);

        let mut circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction err")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction err")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 17, &mut rand::thread_rng())?;
        let (pk, vk) = circuit.compile(&pub_params)?;
        let proof = circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut pi = vec![];
        add_circuit_public_inputs(&circuit, crossover_commitment, fee, &mut pi);

        circuit.verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
    }

    #[test]
    // This circuit sets the wrong value for the first note,
    // which will fail the commitment check and create
    // an incorrect note. This is preventing the user from
    // falsifying their note value.
    fn test_wrong_note_value_one() -> Result<()> {
        // Generate the (a,b) for the note
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        // Declare the secret spend key for the note
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        // Assign the value of the first note as 400, which is incorrect
        let value1 = 500u64;
        let input_note_blinder_one = JubJubScalar::from(100 as u64);
        // Create a deterministic note so that we can assign the blinder and not
        // have inner randomness
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        // Set the position of the note
        note1.set_pos(0);

        let input_note_value_one = JubJubScalar::from(value1);
        // Generate the value commitment of the note from the value and blinder
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        let value2 = 200u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        // Assign the positions of the notes to a position in the tree
        let tree_pos_1 = tree.push(note1.into()).expect("Leaf appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Leaf appending error");

        // Generate the crossover commitment, C.c(v,b)
        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        // Generate the commitment to the first output note, C.c(v,b)
        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        // Generate the commitment to the second output note, C.c(v,b)
        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        // Assign the fee
        let fee = BlsScalar::from(200);

        let mut circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            // This is where the wrong values are inputted
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 18, &mut rand::thread_rng())?;
        let (pk, vk) = circuit.compile(&pub_params)?;
        let proof = circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut pi = vec![];
        add_circuit_public_inputs(&circuit, crossover_commitment, fee, &mut pi);

        assert!(circuit
            .verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
            .is_err());
        Ok(())
    }

    #[test]
    // This circuit sets the wrong value for the second note,
    // which will fail the commitment check and create
    // an incorrect note. This is preventing the user from
    // falsifying their note value.
    fn test_wrong_note_value_two() -> Result<()> {
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        let value1 = 600u64;
        let input_note_blinder_one = JubJubScalar::from(100 as u64);
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        note1.set_pos(0);

        let input_note_value_one = JubJubScalar::from(value1);
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        // Assign an incorrect value to the note. This will fail in the
        // commitment check and the balance check
        let value2 = 800u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        let tree_pos_1 = tree.push(note1.into()).expect("Leaf appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Leaf appending error");

        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        let fee = BlsScalar::from(200);

        let mut circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            // This is where the incorrect values is assigned to the circuit
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 18, &mut rand::thread_rng())?;
        let (pk, vk) = circuit.compile(&pub_params)?;
        let proof = circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut pi = vec![];
        add_circuit_public_inputs(&circuit, crossover_commitment, fee, &mut pi);

        assert!(circuit
            .verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
            .is_err());
        Ok(())
    }

    #[test]
    // This circuit tests to see if a wrong nullifier
    // leads to a failed circuit
    fn test_wrong_nullifier() -> Result<()> {
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        let value1 = 600u64;
        let input_note_blinder_one = JubJubScalar::from(100 as u64);
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        note1.set_pos(0);

        let input_note_value_one = JubJubScalar::from(value1);
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        let value2 = 200u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        let tree_pos_1 = tree.push(note1.into()).expect("Leaf appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Leaf appending error");

        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        let fee = BlsScalar::from(200);

        // The vector entries for the nulllifier are incorrect
        let mut circuit = build_execute_circuit(
            // Here the second nullifier is declared incorrectly
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk1)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 18, &mut rand::thread_rng())?;
        let (pk, vk) = circuit.compile(&pub_params)?;
        let proof = circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut pi = vec![];
        add_circuit_public_inputs(&circuit, crossover_commitment, fee, &mut pi);

        // Assert the test fails
        assert!(circuit
            .verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
            .is_err());
        Ok(())
    }

    #[test]
    // The fee is a public input and is the value
    // paid for processing a transaction. With an
    // incorrect value for PI, the test should fail.
    fn test_wrong_fee() -> Result<()> {
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        let value1 = 600u64;
        let input_note_blinder_one = JubJubScalar::from(100 as u64);
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        note1.set_pos(0);

        let input_note_value_one = JubJubScalar::from(value1);
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        let value2 = 200u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        let tree_pos_1 = tree.push(note1.into()).expect("Leaf appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Leaf appending error");

        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        // Assign a wrong fee so the amount paid and balance gadget check is
        // incorrect
        let fee = BlsScalar::from(20);

        let mut circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            // Here the incorrect fee is added
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 18, &mut rand::thread_rng())?;
        let (pk, vk) = circuit.compile(&pub_params)?;
        let proof = circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut pi = vec![];
        add_circuit_public_inputs(&circuit, crossover_commitment, fee, &mut pi);

        // Assert that the proof will fail
        assert!(circuit
            .verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
            .is_err());
        Ok(())
    }

    #[test]
    // This test pushes the position of the note,
    // after the note position is pushed to the tree.
    // This should fail meaning the user cannot amend
    // the position of the note in the tree after its
    // set.
    fn test_pushing_note_to_wrong_position() -> Result<()> {
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        let value1 = 600u64;
        let input_note_blinder_one = JubJubScalar::from(value1);
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        note1.set_pos(0);

        let input_note_value_one = JubJubScalar::from(600 as u64);
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        let value2 = 200u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        let tree_pos_1 = tree.push(note1.into()).expect("Leaf appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Leaf appending error");

        // After the note has been pushed to the tree, set the position
        // elsewhere, this will cause the the preimage and nullifier to
        // fail
        note2.set_pos(5);

        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        let fee = BlsScalar::from(200);

        let mut circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 18, &mut rand::thread_rng())?;
        let (pk, vk) = circuit.compile(&pub_params)?;
        let proof = circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut pi = vec![];
        add_circuit_public_inputs(&circuit, crossover_commitment, fee, &mut pi);

        // Assert the proof will fail
        assert!(circuit
            .verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
            .is_err());
        Ok(())
    }

    #[test]
    // This test ensures the execute gadget is done correctly
    // by creating two notes and setting their field values
    // in the execute circuit
    fn test_execute_prover_cannot_cheat() -> Result<()> {
        // Generate the (a,b) for the note
        let secret1 = JubJubScalar::from(100 as u64);
        let secret2 = JubJubScalar::from(200 as u64);
        // Declare the secret spend key for the note
        let ssk1 = SecretSpendKey::new(secret1, secret2);
        // Assign the value of the note
        let value1 = 600u64;
        let input_note_blinder_one = JubJubScalar::from(100 as u64);
        // Create a deterministic note so that we can assign the blinder and not
        // have inner randomness
        let mut note1 = circuit_note(ssk1, value1, 0, input_note_blinder_one);
        // Set the position of the note
        note1.set_pos(0);
        // Derive the one time public key, pk_r, for the note
        let input_note_value_one = JubJubScalar::from(value1);
        let input_commitment_one = compute_value_commitment(
            input_note_value_one,
            input_note_blinder_one,
        );

        // Generate the (a,b) for the note
        let secret3 = JubJubScalar::from(300 as u64);
        let secret4 = JubJubScalar::from(400 as u64);
        // Declare the secret spend key for the note
        let ssk2 = SecretSpendKey::new(secret3, secret4);
        // Assign the value of the first note as 400, which is incorrect
        let value2 = 200u64;
        let input_note_blinder_two = JubJubScalar::from(200 as u64);
        // Create a deterministic note so that we can assign the blinder and not
        // have inner randomness
        let mut note2 = circuit_note(ssk2, value2, 0, input_note_blinder_two);
        // Set the position of the note
        note2.set_pos(1);

        let input_note_value_two = JubJubScalar::from(value2);
        // Generate the value commitment of the note from the value and blinder
        let input_commitment_two = compute_value_commitment(
            input_note_value_two,
            input_note_blinder_two,
        );

        let mut tree =
            PoseidonTree::<NoteLeaf, PoseidonAnnotation, MemStore, 17>::new();
        // Assign the postitions of the notes to a position in the tree
        let tree_pos_1 = tree.push(note1.into()).expect("Leaf appending error");
        let tree_pos_2 = tree.push(note2.into()).expect("Leaf appending error");

        // Generate the crossover commitment, C.c(v,b)
        let crossover_commitment_value = JubJubScalar::from(200 as u64);
        let crossover_commitment_blinder = JubJubScalar::from(100 as u64);
        let crossover_commitment = compute_value_commitment(
            crossover_commitment_value,
            crossover_commitment_blinder,
        );

        // Generate the commitment to the first output note, C.c(v,b)
        let obfuscated_note_value_one = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_one = JubJubScalar::from(100 as u64);
        let obfuscated_commitment_one = compute_value_commitment(
            obfuscated_note_value_one,
            obfuscated_note_blinder_one,
        );

        // Generate the commitment to the second output note, C.c(v,b)
        let obfuscated_note_value_two = JubJubScalar::from(200 as u64);
        let obfuscated_note_blinder_two = JubJubScalar::from(200 as u64);
        let obfuscated_commitment_two = compute_value_commitment(
            obfuscated_note_value_two,
            obfuscated_note_blinder_two,
        );

        // Generate the schnorr signatures
        let sig1 =
            schnorr_sign(ssk1.sk_r(note1.stealth_address()), BlsScalar::one());
        let sig2 =
            schnorr_sign(ssk2.sk_r(note2.stealth_address()), BlsScalar::one());

        // Assign the fee
        let fee = BlsScalar::from(200);

        let mut prover_circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![], //input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );

        // Generate Composer & Public Parameters
        let pub_params =
            PublicParameters::setup(1 << 17, &mut rand::thread_rng())?;
        let (pk, vk) = prover_circuit.compile(&pub_params)?;
        let proof = prover_circuit.gen_proof(&pub_params, &pk, b"Execute")?;

        let mut verifier_circuit = build_execute_circuit(
            vec![note1.gen_nullifier(&ssk1), note2.gen_nullifier(&ssk2)],
            vec![note1.hash(), note2.hash()],
            vec![BlsScalar::from(note1.pos()), BlsScalar::from(note2.pos())],
            vec![
                BlsScalar::from(note1.note() as u64),
                BlsScalar::from(note2.note() as u64),
            ],
            vec![
                tree.branch(tree_pos_1)
                    .expect("Branch extraction error")
                    .unwrap(),
                tree.branch(tree_pos_2)
                    .expect("Branch extraction error")
                    .unwrap(),
            ],
            vec![
                ssk1.sk_r(note1.stealth_address()),
                ssk2.sk_r(note2.stealth_address()),
            ],
            vec![
                AffinePoint::from(note1.stealth_address().pk_r()),
                AffinePoint::from(note2.stealth_address().pk_r()),
            ],
            vec![sig1.3, sig2.3],
            vec![input_commitment_one, input_commitment_two],
            vec![*note1.nonce(), *note2.nonce()],
            vec![input_note_value_one.into(), input_note_value_two.into()],
            vec![input_note_blinder_one.into(), input_note_blinder_two.into()],
            vec![
                note1.stealth_address().R().into(),
                note2.stealth_address().R().into(),
            ],
            vec![note1.cipher()[0], note2.cipher()[0]],
            vec![note1.cipher()[1], note2.cipher()[1]],
            vec![note1.cipher()[2], note2.cipher()[2]],
            vec![sig1.0, sig2.0],
            vec![sig1.1, sig2.1],
            vec![sig1.2, sig2.2],
            vec![BlsScalar::one(), BlsScalar::one()],
            crossover_commitment,
            crossover_commitment_value.into(),
            crossover_commitment_blinder.into(),
            vec![obfuscated_commitment_one, obfuscated_commitment_two],
            vec![
                obfuscated_note_value_one.into(),
                obfuscated_note_value_two.into(),
            ],
            vec![
                obfuscated_note_blinder_one.into(),
                obfuscated_note_blinder_two.into(),
            ],
            fee,
        );
        verifier_circuit.compile(&pub_params)?;
        let mut pi = vec![];
        add_circuit_public_inputs(
            &verifier_circuit,
            crossover_commitment,
            fee,
            &mut pi,
        );

        // Assert the proof will fail
        assert!(verifier_circuit
            .verify_proof(&pub_params, &vk, b"Execute", &proof, &pi)
            .is_err());
        Ok(())
    }
}
