// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Defines core types used throughout the WebSocket subscription system.
//!
//! This module includes identifiers for subscriptions and sessions, the topics
//! clients can subscribe to, and any parameters associated with specific
//! subscription types.
//!
//! # Core Concepts
//!
//! - [`Topic`]: Represents the category of events a client subscribes to (e.g.,
//!   new blocks, contract events).
//! - [`SubscriptionId`]: A unique identifier for each active subscription,
//!   typically generated by the server and returned to the client upon
//!   successful subscription.
//! - [`SessionId`]: An identifier for a client's WebSocket connection session,
//!   used to manage all subscriptions associated with that connection.
//!
//! These types ensure clear separation and management of different aspects of
//! the subscription lifecycle.

use crate::jsonrpc::infrastructure::subscription::error::SubscriptionError;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use std::fmt::{self, Display};
use std::str::FromStr;
use uuid::Uuid;

/// Represents the different topics clients can subscribe to via WebSocket.
///
/// Each variant corresponds to a specific type of blockchain event or state
/// change that the client wants to receive real-time notifications about. The
/// topic determines the structure and content of the event data sent to the
/// subscriber.
///
/// # Examples
///
/// Serializing a topic:
///
/// ```
/// # use serde_json;
/// # use rusk::jsonrpc::infrastructure::subscription::types::Topic;
/// let topic = Topic::BlockAcceptance;
/// let serialized = serde_json::to_string(&topic).unwrap();
/// assert_eq!(serialized, "\"BlockAcceptance\"");
/// ```
///
/// Deserializing a topic:
///
/// ```
/// # use serde_json;
/// # use rusk::jsonrpc::infrastructure::subscription::types::Topic;
/// let data = "\"BlockFinalization\"";
/// let deserialized: Topic = serde_json::from_str(data).unwrap();
/// assert_eq!(deserialized, Topic::BlockFinalization);
/// ```
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum Topic {
    /// Subscription topic for notifications when a new block is accepted by
    /// the network node. Corresponds to the `subscribeBlockAcceptance`
    /// WebSocket method.
    ///
    /// Subscribers receive details about the accepted block, potentially
    /// including transaction data if requested via parameters.
    BlockAcceptance,

    /// Subscription topic for notifications when a block becomes finalized
    /// (irreversible). Corresponds to the `subscribeBlockFinalization`
    /// WebSocket method.
    ///
    /// Subscribers receive information about the finalized block, confirming
    /// its permanence in the blockchain.
    BlockFinalization,

    /// Subscription topic for notifications about chain reorganizations
    /// (reorgs). Corresponds to the `subscribeChainReorganization`
    /// WebSocket method.
    ///
    /// Subscribers are notified when the canonical chain changes, receiving
    /// information about the depth of the reorg and the blocks involved.
    ChainReorganization,

    /// Subscription topic for events emitted by specific smart contracts.
    /// Corresponds to the `subscribeContractEvents` WebSocket method.
    ///
    /// Subscribers receive notifications for events matching the specified
    /// contract ID and optional event names provided during subscription.
    ContractEvents,

    /// Subscription topic specifically for transfer events emitted by smart
    /// contracts. Corresponds to the `subscribeContractTransferEvents`
    /// WebSocket method.
    ///
    /// This is a specialized version of `ContractEvents`, focusing only on
    /// transfer-like events, potentially with additional filtering options
    /// like minimum amount.
    ContractTransferEvents,

    /// Subscription topic for notifications when a transaction is accepted
    /// into the mempool. Corresponds to the `subscribeMempoolAcceptance`
    /// WebSocket method.
    ///
    /// Subscribers receive information about transactions entering the
    /// mempool, potentially including full transaction details if
    /// requested.
    MempoolAcceptance,

    /// Subscription topic for general mempool events, such as transaction
    /// removal or replacement. Corresponds to the `subscribeMempoolEvents`
    /// WebSocket method.
    ///
    /// Subscribers receive notifications about various changes occurring
    /// within the mempool beyond simple acceptance.
    MempoolEvents,
}

impl Topic {
    /// Returns the string representation of the topic.
    ///
    /// This method is used for serialization and logging purposes.
    ///
    /// # Examples
    ///
    /// ```
    /// use rusk::jsonrpc::infrastructure::subscription::types::Topic;
    ///
    /// let topic = Topic::BlockAcceptance;
    /// assert_eq!(topic.as_str(), "BlockAcceptance");
    ///
    /// let topic = Topic::BlockFinalization;
    /// assert_eq!(topic.as_str(), "BlockFinalization");
    ///
    /// let topic = Topic::ChainReorganization;
    /// assert_eq!(topic.as_str(), "ChainReorganization");
    ///
    /// let topic = Topic::ContractEvents;
    /// assert_eq!(topic.as_str(), "ContractEvents");
    ///
    /// let topic = Topic::ContractTransferEvents;
    /// assert_eq!(topic.as_str(), "ContractTransferEvents");
    ///
    /// let topic = Topic::MempoolAcceptance;
    /// assert_eq!(topic.as_str(), "MempoolAcceptance");
    ///
    /// let topic = Topic::MempoolEvents;
    /// assert_eq!(topic.as_str(), "MempoolEvents");
    /// ```
    pub fn as_str(&self) -> &'static str {
        match self {
            Topic::BlockAcceptance => "BlockAcceptance",
            Topic::BlockFinalization => "BlockFinalization",
            Topic::ChainReorganization => "ChainReorganization",
            Topic::ContractEvents => "ContractEvents",
            Topic::ContractTransferEvents => "ContractTransferEvents",
            Topic::MempoolAcceptance => "MempoolAcceptance",
            Topic::MempoolEvents => "MempoolEvents",
        }
    }
}

impl Display for Topic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl FromStr for Topic {
    type Err = SubscriptionError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BlockAcceptance" => Ok(Topic::BlockAcceptance),
            "BlockFinalization" => Ok(Topic::BlockFinalization),
            "ChainReorganization" => Ok(Topic::ChainReorganization),
            "ContractEvents" => Ok(Topic::ContractEvents),
            "ContractTransferEvents" => Ok(Topic::ContractTransferEvents),
            "MempoolAcceptance" => Ok(Topic::MempoolAcceptance),
            "MempoolEvents" => Ok(Topic::MempoolEvents),
            _ => Err(SubscriptionError::InvalidTopic(s.to_string())),
        }
    }
}

/// A unique identifier for a WebSocket subscription.
///
/// This ID is generated by the server upon a successful subscription request
/// and is used by the client to manage the subscription (e.g., unsubscribe).
/// It wraps a UUID (`v4`) to ensure uniqueness across all active subscriptions.
///
/// # Examples
///
/// Creating a new `SubscriptionId`:
///
/// ```
/// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
///
/// let sub_id = SubscriptionId::new();
/// println!("New Subscription ID: {}", sub_id);
/// ```
///
/// Converting to and from a string:
///
/// ```
/// use std::str::FromStr;
/// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
///
/// let sub_id = SubscriptionId::new();
/// let id_str = sub_id.to_string();
/// let parsed_id = SubscriptionId::from_str(&id_str).unwrap();
/// assert_eq!(sub_id, parsed_id);
///
/// // Example with a known UUID string
/// let known_uuid_str = "f47ac10b-58cc-4372-a567-0e02b2c3d479";
/// let parsed_from_known = SubscriptionId::from_str(known_uuid_str).unwrap();
/// assert_eq!(parsed_from_known.to_string(), known_uuid_str);
/// ```
///
/// JSON Serialization/Deserialization:
///
/// ```
/// use serde_json;
/// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
///
/// let sub_id = SubscriptionId::new();
/// let json = serde_json::to_string(&sub_id).unwrap();
/// println!("Serialized JSON: {}", json); // e.g., "\"f47ac10b-58cc-4372-a567-0e02b2c3d479\""
///
/// let deserialized: SubscriptionId = serde_json::from_str(&json).unwrap();
/// assert_eq!(sub_id, deserialized);
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)] // Serialize/Deserialize as the inner Uuid string
pub struct SubscriptionId(Uuid);

impl SubscriptionId {
    /// Creates a new, unique `SubscriptionId` using a v4 UUID.
    ///
    /// This method generates a new UUID using the `v4` variant of the UUID
    /// algorithm, ensuring the generated ID is universally unique.
    ///
    /// # Examples
    ///
    /// ```
    /// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
    ///
    /// let sub_id = SubscriptionId::new();
    /// println!("New Subscription ID: {}", sub_id);
    /// ```
    pub fn new() -> Self {
        SubscriptionId(Uuid::new_v4())
    }

    /// Returns the underlying [`Uuid`].
    ///
    /// This method provides direct access to the underlying UUID value,
    /// allowing for inspection or manipulation of the subscription ID.
    ///
    /// # Examples
    ///
    /// ```
    /// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
    ///
    /// let sub_id = SubscriptionId::new();
    /// let inner_uuid = sub_id.inner();
    /// assert_eq!(sub_id.to_string(), inner_uuid.to_string());
    /// ```
    pub fn inner(&self) -> Uuid {
        self.0
    }
}

impl Default for SubscriptionId {
    fn default() -> Self {
        Self::new()
    }
}

impl Display for SubscriptionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Use the hyphenated string representation of the UUID
        write!(f, "{}", self.0)
    }
}

impl FromStr for SubscriptionId {
    type Err = SubscriptionError;

    /// Parses a string slice into a `SubscriptionId`.
    ///
    /// The string must be a valid UUID representation.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Uuid::parse_str(s).map(SubscriptionId).map_err(|e| {
            SubscriptionError::InvalidSubscriptionIdFormat(e.to_string())
        })
    }
}

/// Represents a unique identifier for a client's WebSocket connection session.
///
/// Each active WebSocket connection needs a unique identifier. This `SessionId`
/// newtype wraps a String representation of that identifier (e.g., a
/// stringified ConnectionId from jsonrpsee, or potentially another source).
///
/// It is used internally to group all subscriptions belonging to a single
/// client connection, facilitating cleanup when the connection is closed.
///
/// # Examples
///
/// Creating from a string:
///
/// ```
/// use rusk::jsonrpc::infrastructure::subscription::types::SessionId;
/// use std::str::FromStr;
///
/// let session_str = "session-abc-123";
/// let session_id = SessionId::from_str(session_str).unwrap();
/// assert_eq!(session_id.to_string(), session_str);
/// ```
///
/// Using in a collection:
///
/// ```
/// use std::collections::HashSet;
/// use rusk::jsonrpc::infrastructure::subscription::types::SessionId;
/// use std::str::FromStr;
///
/// let mut active_sessions = HashSet::new();
/// let session1 = SessionId::from_str("sess1").unwrap();
/// let session2 = SessionId::from_str("sess2").unwrap();
/// active_sessions.insert(session1.clone());
/// active_sessions.insert(session2);
///
/// assert!(active_sessions.contains(&session1));
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize)] // Remove Deserialize here
#[serde(transparent)]
pub struct SessionId(String);

// Implement Deserialize separately using try_from
impl<'de> Deserialize<'de> for SessionId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        SessionId::try_from(s).map_err(serde::de::Error::custom)
    }
}

impl SessionId {
    /// Returns a reference to the underlying session ID string.
    pub fn inner(&self) -> &str {
        &self.0
    }
}

// Implement TryFrom<String> for validation
impl TryFrom<String> for SessionId {
    type Error = SubscriptionError;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        if value.is_empty() {
            Err(SubscriptionError::InvalidSessionIdFormat(
                "Session ID cannot be empty".to_string(),
            ))
        } else {
            Ok(SessionId(value))
        }
    }
}

impl Display for SessionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl FromStr for SessionId {
    type Err = SubscriptionError;

    /// Parses a string slice into a `SessionId`.
    ///
    /// Performs basic validation (non-empty) via `TryFrom`.
    ///
    /// # Examples
    ///
    /// ```
    /// use rusk::jsonrpc::infrastructure::subscription::types::SessionId;
    /// use std::str::FromStr;
    ///
    /// let session_str = "session-abc-123";
    /// let session_id = SessionId::from_str(session_str).unwrap();
    /// assert_eq!(session_id.to_string(), session_str);
    /// ```
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        SessionId::try_from(s.to_string())
    }
}
