// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Defines core types used throughout the WebSocket subscription system.
//!
//! This module includes identifiers for subscriptions and sessions, the topics
//! clients can subscribe to, and any parameters associated with specific
//! subscription types.
//!
//! # Core Concepts
//!
//! - [`Topic`]: Represents the category of events a client subscribes to (e.g.,
//!   new blocks, contract events).
//! - [`SubscriptionId`]: A unique identifier for each active subscription,
//!   typically generated by the server and returned to the client upon
//!   successful subscription.
//! - [`SessionId`]: An identifier for a client's WebSocket connection session,
//!   used to manage all subscriptions associated with that connection.
//!
//! These types ensure clear separation and management of different aspects of
//! the subscription lifecycle.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

use crate::jsonrpc::infrastructure::subscription::error::SubscriptionError;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Display};
use std::str::FromStr;
use uuid::Uuid;

/// Represents the different topics clients can subscribe to via WebSocket.
///
/// Each variant corresponds to a specific type of blockchain event or state
/// change that the client wants to receive real-time notifications about. The
/// topic determines the structure and content of the event data sent to the
/// subscriber.
///
/// # Examples
///
/// Serializing a topic:
///
/// ```
/// # use serde_json;
/// # use rusk::jsonrpc::infrastructure::subscription::types::Topic;
/// let topic = Topic::BlockAcceptance;
/// let serialized = serde_json::to_string(&topic).unwrap();
/// assert_eq!(serialized, "\"BlockAcceptance\"");
/// ```
///
/// Deserializing a topic:
///
/// ```
/// # use serde_json;
/// # use rusk::jsonrpc::infrastructure::subscription::types::Topic;
/// let data = "\"BlockFinalization\"";
/// let deserialized: Topic = serde_json::from_str(data).unwrap();
/// assert_eq!(deserialized, Topic::BlockFinalization);
/// ```
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum Topic {
    /// Subscription topic for notifications when a new block is accepted by
    /// the network node. Corresponds to the `subscribeBlockAcceptance`
    /// WebSocket method.
    ///
    /// Subscribers receive details about the accepted block, potentially
    /// including transaction data if requested via parameters.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::BlockAcceptanceEvent`.
    BlockAcceptance,

    /// Subscription topic for notifications when a block becomes finalized
    /// (irreversible). Corresponds to the `subscribeBlockFinalization`
    /// WebSocket method.
    ///
    /// Subscribers receive information about the finalized block, confirming
    /// its permanence in the blockchain.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::BlockFinalizationEvent`.
    BlockFinalization,

    /// Subscription topic for notifications about chain reorganizations
    /// (reorgs). Corresponds to the `subscribeChainReorganization`
    /// WebSocket method.
    ///
    /// Subscribers are notified when the canonical chain changes, receiving
    /// information about the depth of the reorg and the blocks involved.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::ChainReorganizationEvent`.
    ChainReorganization,

    /// Subscription topic for events emitted by specific smart contracts.
    /// Corresponds to the `subscribeContractEvents` WebSocket method.
    ///
    /// Subscribers receive notifications for events matching the specified
    /// contract ID and optional event names provided during subscription.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::ContractEvent`.
    ContractEvents,

    /// Subscription topic specifically for transfer events emitted by smart
    /// contracts. Corresponds to the `subscribeContractTransferEvents`
    /// WebSocket method.
    ///
    /// This is a specialized version of `ContractEvents`, focusing only on
    /// transfer-like events, potentially with additional filtering options
    /// like minimum amount.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::ContractEvent` (specifically transfer
    /// events).
    ContractTransferEvents,

    /// Subscription topic for notifications when a transaction is accepted
    /// into the mempool. Corresponds to the `subscribeMempoolAcceptance`
    /// WebSocket method.
    ///
    /// Subscribers receive information about transactions entering the
    /// mempool, potentially including full transaction details if
    /// requested.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::MempoolAcceptanceEvent`.
    MempoolAcceptance,

    /// Subscription topic for general mempool events, such as transaction
    /// removal or replacement. Corresponds to the `subscribeMempoolEvents`
    /// WebSocket method.
    ///
    /// Subscribers receive notifications about various changes occurring
    /// within the mempool beyond simple acceptance.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::MempoolRemovalEvent`.
    MempoolEvents,
}

impl Topic {
    /// Returns the string representation of the topic.
    ///
    /// This method is used for serialization and logging purposes.
    pub fn as_str(&self) -> &'static str {
        match self {
            Topic::BlockAcceptance => "BlockAcceptance",
            Topic::BlockFinalization => "BlockFinalization",
            Topic::ChainReorganization => "ChainReorganization",
            Topic::ContractEvents => "ContractEvents",
            Topic::ContractTransferEvents => "ContractTransferEvents",
            Topic::MempoolAcceptance => "MempoolAcceptance",
            Topic::MempoolEvents => "MempoolEvents",
        }
    }
}

impl Display for Topic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl FromStr for Topic {
    type Err = SubscriptionError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BlockAcceptance" => Ok(Topic::BlockAcceptance),
            "BlockFinalization" => Ok(Topic::BlockFinalization),
            "ChainReorganization" => Ok(Topic::ChainReorganization),
            "ContractEvents" => Ok(Topic::ContractEvents),
            "ContractTransferEvents" => Ok(Topic::ContractTransferEvents),
            "MempoolAcceptance" => Ok(Topic::MempoolAcceptance),
            "MempoolEvents" => Ok(Topic::MempoolEvents),
            _ => Err(SubscriptionError::InvalidTopic(s.to_string())),
        }
    }
}

/// A unique identifier for a WebSocket subscription.
///
/// This ID is generated by the server upon a successful subscription request
/// and is used by the client to manage the subscription (e.g., unsubscribe).
/// It wraps a UUID (`v4`) to ensure uniqueness across all active subscriptions.
///
/// # Examples
///
/// Creating a new `SubscriptionId`:
///
/// ```
/// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
///
/// let sub_id = SubscriptionId::new();
/// println!("New Subscription ID: {}", sub_id);
/// ```
///
/// Converting to and from a string:
///
/// ```
/// use std::str::FromStr;
/// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
///
/// let sub_id = SubscriptionId::new();
/// let id_str = sub_id.to_string();
/// let parsed_id = SubscriptionId::from_str(&id_str).unwrap();
/// assert_eq!(sub_id, parsed_id);
///
/// // Example with a known UUID string
/// let known_uuid_str = "f47ac10b-58cc-4372-a567-0e02b2c3d479";
/// let parsed_from_known = SubscriptionId::from_str(known_uuid_str).unwrap();
/// assert_eq!(parsed_from_known.to_string(), known_uuid_str);
/// ```
///
/// JSON Serialization/Deserialization:
///
/// ```
/// use serde_json;
/// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
///
/// let sub_id = SubscriptionId::new();
/// let json = serde_json::to_string(&sub_id).unwrap();
/// println!("Serialized JSON: {}", json); // e.g., "\"f47ac10b-58cc-4372-a567-0e02b2c3d479\""
///
/// let deserialized: SubscriptionId = serde_json::from_str(&json).unwrap();
/// assert_eq!(sub_id, deserialized);
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)] // Serialize/Deserialize as the inner Uuid string
pub struct SubscriptionId(Uuid);

impl SubscriptionId {
    /// Creates a new, unique `SubscriptionId` using a v4 UUID.
    ///
    /// This method generates a new UUID using the `v4` variant of the UUID
    /// algorithm, ensuring the generated ID is universally unique.
    ///
    /// # Examples
    ///
    /// ```
    /// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
    ///
    /// let sub_id = SubscriptionId::new();
    /// println!("New Subscription ID: {}", sub_id);
    /// ```
    pub fn new() -> Self {
        SubscriptionId(Uuid::new_v4())
    }

    /// Returns the underlying [`Uuid`].
    ///
    /// This method provides direct access to the underlying UUID value,
    /// allowing for inspection or manipulation of the subscription ID.
    ///
    /// # Examples
    ///
    /// ```
    /// use rusk::jsonrpc::infrastructure::subscription::types::SubscriptionId;
    ///
    /// let sub_id = SubscriptionId::new();
    /// let inner_uuid = sub_id.inner();
    /// assert_eq!(sub_id.to_string(), inner_uuid.to_string());
    /// ```
    pub fn inner(&self) -> Uuid {
        self.0
    }
}

impl Default for SubscriptionId {
    fn default() -> Self {
        Self::new()
    }
}

impl Display for SubscriptionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Use the hyphenated string representation of the UUID
        write!(f, "{}", self.0)
    }
}

impl FromStr for SubscriptionId {
    type Err = SubscriptionError;

    /// Parses a string slice into a `SubscriptionId`.
    ///
    /// The string must be a valid UUID representation.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Uuid::parse_str(s).map(SubscriptionId).map_err(|e| {
            SubscriptionError::InvalidSubscriptionIdFormat(e.to_string())
        })
    }
}
