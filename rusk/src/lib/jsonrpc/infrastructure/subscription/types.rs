// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Defines core types used throughout the WebSocket subscription system.
//!
//! This module includes identifiers for subscriptions and sessions, the topics
//! clients can subscribe to, and any parameters associated with specific
//! subscription types.
//!
//! # Core Concepts
//!
//! - [`Topic`]: Represents the category of events a client subscribes to (e.g.,
//!   new blocks, contract events).
//! - `SubscriptionId` (to be added): A unique identifier for each active
//!   subscription, typically generated by the server and returned to the client
//!   upon successful subscription.
//! - `SessionId` (to be added): An identifier for a client's WebSocket
//!   connection session, used to manage all subscriptions associated with that
//!   connection.
//!
//! These types ensure clear separation and management of different aspects of
//! the subscription lifecycle.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

use crate::jsonrpc::infrastructure::subscription::error::SubscriptionError;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Display};
use std::str::FromStr;

/// Represents the different topics clients can subscribe to via WebSocket.
///
/// Each variant corresponds to a specific type of blockchain event or state
/// change that the client wants to receive real-time notifications about. The
/// topic determines the structure and content of the event data sent to the
/// subscriber.
///
/// # Examples
///
/// Serializing a topic:
///
/// ```
/// # use serde_json;
/// # use rusk::jsonrpc::infrastructure::subscription::types::Topic;
/// let topic = Topic::BlockAcceptance;
/// let serialized = serde_json::to_string(&topic).unwrap();
/// assert_eq!(serialized, "\"BlockAcceptance\"");
/// ```
///
/// Deserializing a topic:
///
/// ```
/// # use serde_json;
/// # use rusk::jsonrpc::infrastructure::subscription::types::Topic;
/// let data = "\"BlockFinalization\"";
/// let deserialized: Topic = serde_json::from_str(data).unwrap();
/// assert_eq!(deserialized, Topic::BlockFinalization);
/// ```
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum Topic {
    /// Subscription topic for notifications when a new block is accepted by
    /// the network node. Corresponds to the `subscribeBlockAcceptance`
    /// WebSocket method.
    ///
    /// Subscribers receive details about the accepted block, potentially
    /// including transaction data if requested via parameters.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::BlockAcceptanceEvent`.
    BlockAcceptance,

    /// Subscription topic for notifications when a block becomes finalized
    /// (irreversible). Corresponds to the `subscribeBlockFinalization`
    /// WebSocket method.
    ///
    /// Subscribers receive information about the finalized block, confirming
    /// its permanence in the blockchain.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::BlockFinalizationEvent`.
    BlockFinalization,

    /// Subscription topic for notifications about chain reorganizations
    /// (reorgs). Corresponds to the `subscribeChainReorganization`
    /// WebSocket method.
    ///
    /// Subscribers are notified when the canonical chain changes, receiving
    /// information about the depth of the reorg and the blocks involved.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::ChainReorganizationEvent`.
    ChainReorganization,

    /// Subscription topic for events emitted by specific smart contracts.
    /// Corresponds to the `subscribeContractEvents` WebSocket method.
    ///
    /// Subscribers receive notifications for events matching the specified
    /// contract ID and optional event names provided during subscription.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::ContractEvent`.
    ContractEvents,

    /// Subscription topic specifically for transfer events emitted by smart
    /// contracts. Corresponds to the `subscribeContractTransferEvents`
    /// WebSocket method.
    ///
    /// This is a specialized version of `ContractEvents`, focusing only on
    /// transfer-like events, potentially with additional filtering options
    /// like minimum amount.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::ContractEvent` (specifically transfer
    /// events).
    ContractTransferEvents,

    /// Subscription topic for notifications when a transaction is accepted
    /// into the mempool. Corresponds to the `subscribeMempoolAcceptance`
    /// WebSocket method.
    ///
    /// Subscribers receive information about transactions entering the
    /// mempool, potentially including full transaction details if
    /// requested.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::MempoolAcceptanceEvent`.
    MempoolAcceptance,

    /// Subscription topic for general mempool events, such as transaction
    /// removal or replacement. Corresponds to the `subscribeMempoolEvents`
    /// WebSocket method.
    ///
    /// Subscribers receive notifications about various changes occurring
    /// within the mempool beyond simple acceptance.
    ///
    /// # Example Payload (Conceptual)
    /// See `rusk::jsonrpc::types::MempoolRemovalEvent`.
    MempoolEvents,
}

impl Topic {
    /// Returns the string representation of the topic.
    ///
    /// This method is used for serialization and logging purposes.
    pub fn as_str(&self) -> &'static str {
        match self {
            Topic::BlockAcceptance => "BlockAcceptance",
            Topic::BlockFinalization => "BlockFinalization",
            Topic::ChainReorganization => "ChainReorganization",
            Topic::ContractEvents => "ContractEvents",
            Topic::ContractTransferEvents => "ContractTransferEvents",
            Topic::MempoolAcceptance => "MempoolAcceptance",
            Topic::MempoolEvents => "MempoolEvents",
        }
    }
}

impl Display for Topic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl FromStr for Topic {
    type Err = SubscriptionError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BlockAcceptance" => Ok(Topic::BlockAcceptance),
            "BlockFinalization" => Ok(Topic::BlockFinalization),
            "ChainReorganization" => Ok(Topic::ChainReorganization),
            "ContractEvents" => Ok(Topic::ContractEvents),
            "ContractTransferEvents" => Ok(Topic::ContractTransferEvents),
            "MempoolAcceptance" => Ok(Topic::MempoolAcceptance),
            "MempoolEvents" => Ok(Topic::MempoolEvents),
            _ => Err(SubscriptionError::InvalidTopic(s.to_string())),
        }
    }
}
