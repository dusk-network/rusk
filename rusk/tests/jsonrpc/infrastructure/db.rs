// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Tests for the Database Adapter infrastructure, including mock and real
//! implementations.

use crate::jsonrpc::utils::{
    create_mock_block, create_mock_moonlight_group, MockArchiveAdapter,
    MockDbAdapter,
};
use futures::executor::block_on;
use node::database::rocksdb::MD_HASH_KEY;
use rusk::jsonrpc::infrastructure::archive::ArchiveAdapter;
use rusk::jsonrpc::infrastructure::db::DatabaseAdapter;
use rusk::jsonrpc::infrastructure::error::{ArchiveError, DbError};
use std::collections::HashMap;

// --- MockDbAdapter Tests ---

#[tokio::test]
async fn mock_db_get_block_by_hash_found() {
    let block1 = create_mock_block(100, "hash_abc");
    let mut blocks_by_hash = HashMap::new();
    blocks_by_hash.insert(block1.header.hash.clone(), block1.clone());
    let adapter = MockDbAdapter {
        blocks_by_hash,
        ..Default::default()
    };

    // Use the deterministic hash generated by create_mock_block
    let hash_hex = hex::encode([100u8; 32]);
    let result = adapter.get_block_by_hash(&hash_hex, false).await;

    assert!(result.is_ok());
    assert_eq!(result.unwrap(), Some(block1));
}

#[tokio::test]
async fn mock_db_get_block_by_hash_not_found() {
    let adapter = MockDbAdapter::default();
    // Use a valid 64-char hex string that's not expected to be in the default
    // mock map
    let nonexistent_valid_hash = "00".repeat(32);
    let result = adapter
        .get_block_by_hash(&nonexistent_valid_hash, false)
        .await;
    assert!(result.is_ok());
    assert!(result.unwrap().is_none());
}

#[tokio::test]
async fn mock_db_get_block_by_hash_error() {
    let forced_error = DbError::QueryFailed("Forced DB error".into());
    let adapter = MockDbAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_block_by_hash("any_hash", false).await;
    assert!(result.is_err());
    assert_eq!(result.err().unwrap(), forced_error);
}

#[tokio::test]
async fn mock_db_get_block_by_height_found() {
    let block1 = create_mock_block(100, "hash_abc");
    let mut blocks_by_height = HashMap::new();
    blocks_by_height.insert(100, block1.clone());
    let mut blocks_by_hash = HashMap::new();
    blocks_by_hash.insert(block1.header.hash.clone(), block1.clone());
    let adapter = MockDbAdapter {
        blocks_by_height,
        blocks_by_hash,
        ..Default::default()
    };

    let result = adapter.get_block_by_height(100, false).await;
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), Some(block1));
}

#[tokio::test]
async fn mock_db_get_block_by_height_not_found() {
    let adapter = MockDbAdapter::default();
    let result = adapter.get_block_by_height(999, false).await;
    assert!(result.is_ok());
    assert!(result.unwrap().is_none());
}

#[tokio::test]
async fn mock_db_get_block_by_height_error() {
    let forced_error = DbError::InternalError("Forced internal".into());
    let adapter = MockDbAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_block_by_height(100, false).await;
    assert!(result.is_err());
    assert_eq!(result.err().unwrap(), forced_error);
}

#[tokio::test]
async fn mock_db_get_latest_block_found() {
    let block_latest = create_mock_block(105, "hash_latest");
    let mut mock_db = MockDbAdapter {
        latest_height: 105,
        ..Default::default()
    };
    // Setup for default get_latest_block impl
    let tip_hash = block_latest.header.hash.clone();
    mock_db
        .metadata
        .insert(MD_HASH_KEY.to_vec(), hex::decode(&tip_hash).unwrap());
    mock_db
        .headers_by_hash
        .insert(tip_hash.clone(), block_latest.header.clone());
    mock_db
        .blocks_by_hash
        .insert(tip_hash.clone(), block_latest.clone());
    mock_db.blocks_by_height.insert(105, block_latest.clone());

    let result = mock_db.get_latest_block(false).await;
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), block_latest);
}

#[tokio::test]
async fn mock_db_get_latest_block_not_found_in_map() {
    let mut mock_db = MockDbAdapter {
        latest_height: 100,
        ..Default::default()
    };
    let tip_hash = hex::encode([100u8; 32]);
    mock_db
        .metadata
        .insert(MD_HASH_KEY.to_vec(), hex::decode(tip_hash).unwrap());

    let result = block_on(mock_db.get_latest_block(false));
    assert!(result.is_err());
    let err = result.unwrap_err();
    // Default impl path: get_latest_block -> get_block_height ->
    // metadata_op_read(Ok) -> get_block_header_by_hash(Err) ->
    // get_latest_block(Err) If get_block_header_by_hash for tip hash
    // returns None, get_block_height returns Err(NotFound("Tip block header not
    // found")) Then get_latest_block propagates this error.
    assert_matches::assert_matches!(
        err,
        DbError::NotFound(msg) if msg.contains("Tip block header not found")
    );
}

#[tokio::test]
async fn mock_db_get_latest_block_error() {
    let forced_error = DbError::NotFound("Forced not found".into());
    let adapter = MockDbAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_latest_block(false).await;
    assert!(result.is_err());
    assert_eq!(result.err().unwrap(), forced_error);
}

// --- Tests for get_blocks_range ---

#[tokio::test]
async fn mock_db_get_blocks_range_success() {
    let block1 = create_mock_block(100, "hash_100");
    let block2 = create_mock_block(101, "hash_101");
    let block3 = create_mock_block(102, "hash_102");
    let mut mock_db = MockDbAdapter::default();
    let blocks_vec = vec![block1.clone(), block2.clone(), block3.clone()];

    for block in blocks_vec.iter() {
        mock_db
            .blocks_by_height
            .insert(block.header.height, block.clone());
        mock_db
            .blocks_by_hash
            .insert(block.header.hash.clone(), block.clone());
        mock_db
            .headers_by_hash
            .insert(block.header.hash.clone(), block.header.clone());
    }

    let result = mock_db.get_blocks_range(100, 102, false).await;
    assert!(result.is_ok());
    let blocks = result.unwrap();
    assert_eq!(blocks.len(), 3);
    assert_eq!(blocks[0], block1);
    assert_eq!(blocks[1], block2);
    assert_eq!(blocks[2], block3);
}

#[tokio::test]
async fn mock_db_get_blocks_range_not_found() {
    let block1 = create_mock_block(100, "hash_100");
    // Block 101 is missing
    let block3 = create_mock_block(102, "hash_102");
    let mut mock_db = MockDbAdapter::default();

    mock_db.blocks_by_height.insert(100, block1.clone());
    mock_db
        .blocks_by_hash
        .insert(block1.header.hash.clone(), block1.clone());
    mock_db
        .headers_by_hash
        .insert(block1.header.hash.clone(), block1.header.clone());

    mock_db.blocks_by_height.insert(102, block3.clone());
    mock_db
        .blocks_by_hash
        .insert(block3.header.hash.clone(), block3.clone());
    mock_db
        .headers_by_hash
        .insert(block3.header.hash.clone(), block3.header.clone());

    let result = mock_db.get_blocks_range(100, 102, false).await;
    // Default impl uses join_all + filter_map, so missing block results in Ok
    // with found blocks
    assert!(result.is_ok());
    let blocks = result.unwrap();
    assert_eq!(blocks.len(), 2);
    assert_eq!(blocks[0], block1);
    assert_eq!(blocks[1], block3);
}

#[tokio::test]
async fn mock_db_get_blocks_range_empty() {
    let adapter = MockDbAdapter::default();
    let result = adapter.get_blocks_range(100, 99, false).await; // Invalid range
    assert!(result.is_err());
    // Default impl returns InternalError for invalid range
    assert_matches::assert_matches!(
        result.unwrap_err(),
        DbError::InternalError(msg) if msg.contains("Start height cannot be greater than end height")
    );

    let result_ok = adapter.get_blocks_range(100, 100, false).await; // Range of 1, block not found
                                                                     // Default impl returns Ok([]) if block 100 is not found
    assert!(result_ok.is_ok());
    assert!(result_ok.unwrap().is_empty());

    // This check is redundant now, remove it or keep assertion for
    // InternalError let result_empty_ok = adapter.get_blocks_range(100,
    // 99, false).await; assert!(result_empty_ok.is_err()); // Should fail
    // validation
}

#[tokio::test]
async fn mock_db_get_blocks_range_force_error() {
    let forced_error = DbError::InternalError("Forced range error".into());
    let adapter = MockDbAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_blocks_range(100, 102, false).await;
    assert!(result.is_err());
    assert_eq!(result.err().unwrap(), forced_error);
}

// --- Tests for get_blocks_by_hashes ---

#[tokio::test]
async fn mock_db_get_blocks_by_hashes_success() {
    let block1 = create_mock_block(100, "hash_100");
    let block2 = create_mock_block(101, "hash_101");
    let mut blocks_by_hash = HashMap::new();
    blocks_by_hash.insert(block1.header.hash.clone(), block1.clone());
    blocks_by_hash.insert(block2.header.hash.clone(), block2.clone());
    let adapter = MockDbAdapter {
        blocks_by_hash,
        ..Default::default()
    };

    let hash1_hex = hex::encode([100u8; 32]);
    let hash2_hex = hex::encode([101u8; 32]);
    let hashes = vec![hash1_hex, hash2_hex];

    let result = adapter.get_blocks_by_hashes(&hashes, false).await;
    assert!(result.is_ok());
    let blocks_opt = result.unwrap();
    assert_eq!(blocks_opt.len(), 2);
    assert_eq!(blocks_opt[0], Some(block1));
    assert_eq!(blocks_opt[1], Some(block2));
}

#[tokio::test]
async fn mock_db_get_blocks_by_hashes_mixed_results() {
    let block1 = create_mock_block(100, &hex::encode([100u8; 32])); // Found
    let mut blocks_by_hash = HashMap::new();
    blocks_by_hash.insert(block1.header.hash.clone(), block1.clone());
    let adapter = MockDbAdapter {
        blocks_by_hash,
        ..Default::default()
    };

    let hash1_hex = hex::encode([100u8; 32]); // Found
    let hash_non_existent = hex::encode([222u8; 32]); // Not Found
    let hash_invalid = "invalid-hex".to_string();
    let hashes = vec![hash1_hex, hash_non_existent, hash_invalid];

    let result = adapter.get_blocks_by_hashes(&hashes, false).await;
    // Default impl uses try_join_all, which returns the first error
    assert!(result.is_err());
    assert_matches::assert_matches!(
        result.unwrap_err(),
        DbError::QueryFailed(msg) if msg.contains("Invalid block hash format/length")
    );
}

#[tokio::test]
async fn mock_db_get_blocks_by_hashes_all_not_found_or_invalid() {
    let adapter = MockDbAdapter::default(); // Empty mock
    let hashes = vec![
        hex::encode([1u8; 32]),     // Valid format, not found
        "invalid-hash".to_string(), // Invalid format
        hex::encode([2u8; 32]),     // Valid format, not found
    ];
    let result = adapter.get_blocks_by_hashes(&hashes, false).await;
    // try_join_all propagates the first error (QueryFailed from invalid hash)
    assert!(result.is_err());
    assert_matches::assert_matches!(
        result.unwrap_err(),
        DbError::QueryFailed(msg) if msg.contains("Invalid block hash format/length")
    );
}

#[tokio::test]
async fn mock_db_get_blocks_by_hashes_empty_input() {
    let adapter = MockDbAdapter::default();
    let hashes: Vec<String> = vec![];
    let result = adapter.get_blocks_by_hashes(&hashes, false).await;
    assert!(result.is_ok());
    assert!(result.unwrap().is_empty());
}

#[tokio::test]
async fn mock_db_get_blocks_by_hashes_force_error() {
    let block1 = create_mock_block(100, "hash_100");
    let mut blocks_by_hash = HashMap::new();
    blocks_by_hash.insert(block1.header.hash.clone(), block1.clone());

    let forced_error = DbError::InternalError("Forced batch error".into());
    let adapter = MockDbAdapter {
        blocks_by_hash,
        // Force error only if hash isn't the known one? No, mock forces
        // globally.
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let hashes = vec!["hash_100_100".to_string(), "hash_other".to_string()];
    let result = adapter.get_blocks_by_hashes(&hashes, false).await;
    assert!(result.is_err());
    // Because join_all stops on first error, we expect the forced error.
    assert_eq!(result.err().unwrap(), forced_error);
}

// --- MockArchiveAdapter Tests ---

#[tokio::test]
async fn mock_archive_get_moonlight_txs_found() {
    let group1 = create_mock_moonlight_group("tx_abc", 90);
    let group2 = create_mock_moonlight_group("tx_def", 95);
    let mut txs_by_memo = HashMap::new();
    txs_by_memo
        .insert(b"aabbcc".to_vec(), vec![group1.clone(), group2.clone()]);
    let adapter = MockArchiveAdapter {
        txs_by_memo,
        ..Default::default()
    };

    let result = adapter.get_moonlight_txs_by_memo(b"aabbcc".to_vec()).await;
    assert!(result.is_ok());
    let groups_opt = result.unwrap();
    assert!(groups_opt.is_some());
    let groups = groups_opt.unwrap();
    assert_eq!(groups.len(), 2);
    assert_eq!(groups[0], group1);
    assert_eq!(groups[1], group2);
}

#[tokio::test]
async fn mock_archive_get_moonlight_txs_not_found() {
    let adapter = MockArchiveAdapter::default();
    let result = adapter.get_moonlight_txs_by_memo(b"ffffff".to_vec()).await;
    assert!(result.is_ok());
    let groups_opt = result.unwrap();
    assert!(groups_opt.map_or(true, |g| g.is_empty()));
}

#[tokio::test]
async fn mock_archive_get_moonlight_txs_error() {
    let forced_error = ArchiveError::QueryFailed("Forced query fail".into());
    let adapter = MockArchiveAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_moonlight_txs_by_memo(b"aabbcc".to_vec()).await;
    assert!(result.is_err());
    assert_eq!(result.err().unwrap(), forced_error);
}

#[tokio::test]
async fn mock_archive_get_last_height_success() {
    let adapter = MockArchiveAdapter {
        last_archived_block: Some((98, "dummy_hash".to_string())),
        ..Default::default()
    };

    let result = adapter.get_last_archived_block_height().await;
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 98);
}

#[tokio::test]
async fn mock_archive_get_last_height_error() {
    let forced_error = ArchiveError::InternalError("Forced internal".into());
    let adapter = MockArchiveAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_last_archived_block_height().await;
    assert!(result.is_err());
    assert_eq!(result.err().unwrap(), forced_error);
}

// --- RuskArchiveAdapter Tests ---

#[cfg(feature = "archive")]
mod rusk_archive_adapter_tests {
    use crate::jsonrpc::utils::setup_test_archive;
    use node::archive::Archive;
    use rusk::jsonrpc::infrastructure::archive::{
        ArchiveAdapter, RuskArchiveAdapter,
    };
    use rusk::jsonrpc::infrastructure::error::ArchiveError;
    use std::sync::Arc;

    #[tokio::test]
    async fn rusk_archive_get_last_height() {
        let (_temp_dir, archive): (_, Archive) = setup_test_archive().await;
        // Check the result of the direct call first
        let direct_result = archive.fetch_last_finalized_block().await;
        let expected_height =
            direct_result.as_ref().map(|(h, _)| *h).unwrap_or(0);

        let adapter = RuskArchiveAdapter::new(Arc::new(archive));
        let adapter_result = adapter.get_last_archived_block_height().await;

        // If the direct call failed (e.g., empty archive), expect adapter error
        // Otherwise, expect Ok with the same height
        match direct_result {
            Err(_) => {
                assert!(adapter_result.is_err());
                assert_matches::assert_matches!(
                    adapter_result.unwrap_err(),
                    ArchiveError::QueryFailed(_)
                );
            }
            Ok(_) => {
                assert!(adapter_result.is_ok());
                assert_eq!(adapter_result.unwrap(), expected_height);
            }
        }
    }

    #[tokio::test]
    async fn rusk_archive_get_moonlight_history_invalid_base58() {
        let (_temp_dir, archive) = setup_test_archive().await;
        let adapter = RuskArchiveAdapter::new(Arc::new(archive));
        // Call the correct method with invalid base58
        let result = adapter
            .get_moonlight_transaction_history(
                "invalid-base58-*&^".to_string(), // Invalid base58 input
                None,
                None,
                None,
            )
            .await;

        assert!(result.is_err()); // Expecting an error
        match result.err().unwrap() {
            ArchiveError::QueryFailed(msg) => {
                // Check if the error message indicates invalid base58 or pk
                // bytes
                assert!(
                    msg.contains("Invalid Base58")
                        || msg.contains("Invalid public key bytes")
                )
            }
            _ => panic!("Unexpected error type, expected QueryFailed"),
        }
    }

    #[tokio::test]
    async fn rusk_archive_get_moonlight_txs_not_found() {
        let (_temp_dir, archive) = setup_test_archive().await;
        let adapter = RuskArchiveAdapter::new(Arc::new(archive));
        let valid_memo_hex = hex::encode([1u8; 32]);
        let result = adapter
            .get_moonlight_txs_by_memo(hex::decode(&valid_memo_hex).unwrap())
            .await;

        assert!(result.is_ok());
        let groups_opt = result.unwrap();
        assert!(groups_opt.map_or(true, |g| g.is_empty()));
    }
}

// --- RuskDbAdapter Tests ---

#[cfg(feature = "chain")]
mod rusk_db_adapter_tests {
    use crate::jsonrpc::utils::setup_test_db;
    use rusk::jsonrpc::infrastructure::db::{DatabaseAdapter, RuskDbAdapter};
    use rusk::jsonrpc::infrastructure::error::DbError;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    #[tokio::test]
    async fn rusk_db_get_block_by_hash_invalid_hex() {
        let (_temp_dir, db) = setup_test_db();
        let adapter = RuskDbAdapter::new(Arc::new(RwLock::new(db)));

        let result = adapter.get_block_by_hash("invalid-hex-hash", true).await;

        assert!(result.is_err());
        // Real adapter returns InternalError on hex decode failure
        assert_matches::assert_matches!(
            result.unwrap_err(),
            DbError::InternalError(msg) if msg.contains("Invalid block hash hex")
        );
    }

    #[tokio::test]
    async fn rusk_db_get_block_by_hash_not_found() {
        let (_temp_dir, db) = setup_test_db();
        let adapter = RuskDbAdapter::new(Arc::new(RwLock::new(db)));
        // Use a valid hash format, but one that won't exist
        let non_existent_hash = hex::encode([0u8; 32]);

        let result = adapter.get_block_by_hash(&non_existent_hash, true).await;

        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
    }

    #[tokio::test]
    async fn rusk_db_get_block_by_height_not_found() {
        let (_temp_dir, db) = setup_test_db();
        let adapter = RuskDbAdapter::new(Arc::new(RwLock::new(db)));
        let non_existent_height = 9999u64;

        let result = adapter
            .get_block_by_height(non_existent_height, false)
            .await;

        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
    }

    #[tokio::test]
    async fn rusk_db_get_latest_block_not_found() {
        let (_temp_dir, db) = setup_test_db();
        let adapter = RuskDbAdapter::new(Arc::new(RwLock::new(db)));
        // An empty DB won't have the tip hash metadata

        let result = adapter.get_latest_block(false).await;

        assert!(result.is_err());
        // Real adapter returns NotFound when metadata key is missing
        assert_matches::assert_matches!(
            result.unwrap_err(),
            DbError::NotFound(msg) if msg.contains("Tip hash metadata key not found")
        );
    }

    /*
    // Tests requiring data insertion are complex for unit testing RuskDbAdapter.
    // Need node::database::{Ledger, Metadata, DB} traits and real block data.

    #[tokio::test]
    async fn rusk_db_get_block_by_hash_found_and_conversion() {
        let (_temp_dir, db) = setup_test_db();
        let block = ledger::Block::default(); // Need a real block
        let label = ledger::Label::Final(0);

        // Insert block and label into db
        db.update(|txn| {
           txn.store_block(block.header(), &[], &[], label)?;
           Ok(())
        }).expect("DB update failed");

        let adapter = RuskDbAdapter::new(Arc::new(RwLock::new(db)));
        let block_hash_hex = hex::encode(block.header().hash);

        let result = adapter.get_block_by_hash(&block_hash_hex).await;

        assert!(result.is_ok());
        let block_opt = result.unwrap();
        assert!(block_opt.is_some());
        let api_block = block_opt.unwrap();

        // Assert conversion
        assert_eq!(api_block.header.hash, block_hash_hex);
        assert_eq!(api_block.status, BlockStatus::Final);
        // ... other assertions ...
    }

    // Similar tests needed for get_block_by_height and get_latest_block
    */
}

// --- Tests for get_block_headers_range ---

#[tokio::test]
async fn mock_db_get_block_headers_range_success() {
    let block1 = create_mock_block(100, &hex::encode([100u8; 32]));
    let block2 = create_mock_block(101, &hex::encode([101u8; 32]));
    let block3 = create_mock_block(102, &hex::encode([102u8; 32]));
    let header1 = block1.header.clone();
    let header2 = block2.header.clone();
    let header3 = block3.header.clone();

    let mut mock_db = MockDbAdapter {
        latest_height: 102,
        ..Default::default()
    };

    // Populate maps required by default impl chain:
    // get_block_headers_range -> get_block_header_by_height ->
    // get_block_hash_by_height (requires blocks_by_height) ->
    // get_block_header_by_hash (requires headers_by_hash)
    mock_db.headers_by_height.insert(100, header1.clone());
    mock_db.headers_by_height.insert(101, header2.clone());
    mock_db.headers_by_height.insert(102, header3.clone());
    mock_db
        .headers_by_hash
        .insert(header1.hash.clone(), header1.clone());
    mock_db
        .headers_by_hash
        .insert(header2.hash.clone(), header2.clone());
    mock_db
        .headers_by_hash
        .insert(header3.hash.clone(), header3.clone());
    // Need blocks_by_height for mock get_block_hash_by_height
    mock_db.blocks_by_height.insert(100, block1.clone());
    mock_db.blocks_by_height.insert(101, block2.clone());
    mock_db.blocks_by_height.insert(102, block3.clone());

    let result = mock_db.get_block_headers_range(100, 102).await;
    assert!(result.is_ok());
    let headers = result.unwrap();
    assert_eq!(headers.len(), 3);
    assert_eq!(headers[0], header1);
    assert_eq!(headers[1], header2);
    assert_eq!(headers[2], header3);
}

#[tokio::test]
async fn mock_db_get_block_headers_range_not_found() {
    let block1 = create_mock_block(100, &hex::encode([100u8; 32]));
    let block3 = create_mock_block(102, &hex::encode([102u8; 32]));
    let header1 = block1.header.clone();
    let header3 = block3.header.clone();
    let mut mock_db = MockDbAdapter {
        latest_height: 102,
        ..Default::default()
    };

    // Populate maps required by default impl chain
    mock_db.headers_by_height.insert(100, header1.clone());
    mock_db.headers_by_height.insert(102, header3.clone());
    mock_db
        .headers_by_hash
        .insert(header1.hash.clone(), header1.clone());
    mock_db
        .headers_by_hash
        .insert(header3.hash.clone(), header3.clone());
    // Need blocks_by_height for mock get_block_hash_by_height
    mock_db.blocks_by_height.insert(100, block1.clone());
    // Height 101 is missing
    mock_db.blocks_by_height.insert(102, block3.clone());

    let result = mock_db.get_block_headers_range(100, 102).await;
    // Default impl uses join_all + filter_map, returns Ok with found headers
    assert!(result.is_ok());
    let headers = result.unwrap();
    assert_eq!(headers.len(), 2);
    assert_eq!(headers[0], header1);
    assert_eq!(headers[1], header3);
}

#[tokio::test]
async fn mock_db_get_block_headers_range_empty() {
    let adapter = MockDbAdapter::default();
    let result = adapter.get_block_headers_range(100, 99).await; // Invalid range
    assert!(result.is_err());
    // Default impl returns InternalError for invalid range
    assert_matches::assert_matches!(
        result.unwrap_err(),
        DbError::InternalError(msg) if msg.contains("Start height cannot be greater than end height")
    );

    let result_ok = adapter.get_block_headers_range(100, 100).await; // Range of 1, header not found
                                                                     // Default impl uses join_all + filter_map, returns Ok([]) for not found
    assert!(result_ok.is_ok());
    assert!(result_ok.unwrap().is_empty());
}

#[tokio::test]
async fn mock_db_get_block_headers_range_force_error() {
    let forced_error =
        DbError::InternalError("Forced header range error".into());
    let adapter = MockDbAdapter {
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let result = adapter.get_block_headers_range(100, 102).await;
    assert!(result.is_err());
    // Because join_all stops on first error, we expect the forced error.
    assert_eq!(result.err().unwrap(), forced_error);
}

// --- Tests for get_block_headers_by_hashes ---

#[tokio::test]
async fn mock_db_get_block_headers_by_hashes_success() {
    let block1 = create_mock_block(100, "header_100");
    let block2 = create_mock_block(101, "header_101");
    let mut headers_by_hash = HashMap::new();
    headers_by_hash.insert(block1.header.hash.clone(), block1.header.clone());
    headers_by_hash.insert(block2.header.hash.clone(), block2.header.clone());
    let adapter = MockDbAdapter {
        headers_by_hash,
        ..Default::default()
    };

    let hash1_hex = hex::encode([100u8; 32]);
    let hash2_hex = hex::encode([101u8; 32]);
    let hashes = vec![hash1_hex, hash2_hex];

    let result = adapter.get_block_headers_by_hashes(&hashes).await;
    assert!(result.is_ok());
    let headers_opt = result.unwrap();
    assert_eq!(headers_opt.len(), 2);
    assert_eq!(headers_opt[0], Some(block1.header));
    assert_eq!(headers_opt[1], Some(block2.header));
}

#[tokio::test]
async fn mock_db_get_block_headers_by_hashes_mixed_results() {
    let block1 = create_mock_block(100, "header_100"); // Found
    let mut headers_by_hash = HashMap::new();
    headers_by_hash.insert(block1.header.hash.clone(), block1.header.clone());
    let adapter = MockDbAdapter {
        headers_by_hash,
        ..Default::default()
    };

    let hash1_hex = hex::encode([100u8; 32]); // Found
    let hash_non_existent = hex::encode([222u8; 32]); // Not Found
    let hash_invalid = "invalid-hex".to_string();
    let hashes = vec![hash1_hex, hash_non_existent, hash_invalid];

    let result = adapter.get_block_headers_by_hashes(&hashes).await;
    // Default impl uses try_join_all, which returns the first error
    assert!(result.is_err());
    assert_matches::assert_matches!(
        result.unwrap_err(),
        DbError::QueryFailed(msg) if msg.contains("Invalid block hash format/length")
    );
}

#[tokio::test]
async fn mock_db_get_block_headers_by_hashes_all_not_found_or_invalid() {
    let adapter = MockDbAdapter::default(); // Empty mock
    let hashes = vec![
        hex::encode([1u8; 32]),     // Valid format, not found
        "invalid-hash".to_string(), // Invalid format
        hex::encode([2u8; 32]),     // Valid format, not found
    ];
    let result = adapter.get_block_headers_by_hashes(&hashes).await;
    // Default impl uses try_join_all, which returns the first error
    assert!(result.is_err());
    assert_matches::assert_matches!(
        result.unwrap_err(),
        DbError::QueryFailed(msg) if msg.contains("Invalid block hash format/length")
    );
}

#[tokio::test]
async fn mock_db_get_block_headers_by_hashes_empty_input() {
    let adapter = MockDbAdapter::default();
    let hashes: Vec<String> = vec![];
    let result = adapter.get_block_headers_by_hashes(&hashes).await;
    assert!(result.is_ok());
    assert!(result.unwrap().is_empty());
}

#[tokio::test]
async fn mock_db_get_block_headers_by_hashes_force_error() {
    let header1 = create_mock_block(100, "header_100").header;
    let mut headers_by_hash = HashMap::new();
    headers_by_hash.insert(header1.hash.clone(), header1.clone());

    let forced_error =
        DbError::InternalError("Forced header batch error".into());
    let adapter = MockDbAdapter {
        headers_by_hash,
        force_error: Some(forced_error.clone()),
        ..Default::default()
    };

    let hashes = vec!["hash_100_100".to_string(), "hash_other".to_string()];
    let result = adapter.get_block_headers_by_hashes(&hashes).await;
    assert!(result.is_err());
    // Because join_all stops on first error, we expect the forced error.
    assert_eq!(result.err().unwrap(), forced_error);
}
